# Auto_Dev_Team

**Auto_Dev_Team** — это легковесный Python-фреймворк для автономной разработки, где команда из трех AI-агентов (Архитектор, Разработчик и QA-инженер) итеративно работает над созданием, ревью и улучшением кода на основе вашего технического задания.

Этот проект демонстрирует мощь мульти-агентных систем для автоматизации цикла разработки ПО, от планирования до утверждения готового продукта.

---

## Особенности

*   **Командная работа AI:** Три специализированных агента с уникальными ролями для достижения наилучшего результата.
    *   **Архитектор:** Проектирует четкий и структурированный технический план.
    *   **Разработчик:** Пишет чистый, документированный Python-код по плану.
    *   **QA-инженер:** Проводит дотошное ревью, ищет ошибки и пишет `pytest` unit-тесты.
*   **Итеративный процесс:** Агенты работают в цикле "код-ревью-доработка", пока QA-инженер не одобрит финальный результат.
*   **Простота и легковесность:** Весь фреймворк реализован в одном скрипте, без сложных зависимостей.
*   **Гибкость:** Легко адаптируется для использования с различными моделями Google Gemini или Google Gemma.

---

## Быстрый старт

### 1. Клонирование репозитория

```bash
git clone https://github.com/AkiraK000/Auto_Dev_Team.git
cd Auto_Dev_Team
```

### 2. Установка зависимостей

Проект требует `google-generativeai`.

```bash
pip install google-generativeai
```

### 3. Настройка API-ключа

Откройте файл `main.py` и вставьте ваш API-ключ от Google AI Studio в эту строку:

```python
# Вставьте ваш ключ сюда
API_KEY = "" 
```
*Для безопасности рекомендуется использовать переменные окружения или другие методы управления секретами.*

### 4. Запуск

Запустите скрипт из терминала или в вашей среде разработки:

```bash
python main.py
```

Программа попросит вас ввести техническое задание. Опишите задачу (например, "Создай функцию, которая вычисляет факториал числа") и наблюдайте за работой команды агентов!

---

## Как это работает

1.  **Ввод задачи:** Пользователь (вы) дает высокоуровневое описание задачи.
2.  **Планирование:** **Архитектор** получает задачу и декомпозирует ее в подробный технический план.
3.  **Разработка:** **Разработчик** получает план и пишет первую версию кода.
4.  **Контроль качества:** **QA-инженер** получает код, анализирует его на наличие ошибок, соответствие стандартам и потенциальные проблемы. Он пишет unit-тесты и выносит вердикт: "КОД ОДОБРЕН" или "КОД ТРЕБУЕТ ДОРАБОТКИ".
5.  **Итерация:** Если код требует доработки, он вместе с рецензией QA возвращается к **Разработчику**. Цикл повторяется до тех пор, пока QA не будет полностью удовлетворен качеством кода.
6.  **Результат:** Вы получаете финальный, одобренный и протестированный код.

---

## Вклад в проект (Contributing)

Этот проект является open-source, и любой вклад приветствуется! Если у вас есть идеи по улучшению, не стесняйтесь создавать Issues или Pull Requests.

**Возможные направления для развития:**
*   Добавление поддержки других LLM-провайдеров (Anthropic, Ollama, Groq).
*   Возможность сохранения и загрузки истории разработки.
*   Интеграция с файловой системой для работы с несколькими файлами.
*   Создание веб-интерфейса (например, с помощью Gradio или Streamlit).
*   Совмещение с LangChain для интеграции Tool Calling или RAG.

---

## Лицензия

Этот проект распространяется под лицензией **MIT**. Подробности смотрите в файле `LICENSE`.

---
## Слово от создателя проекта
Если вам нравится идея и вы хотите предложить решения для улучшения проекта, то можете связаться со мной через Telegram или email.

Мой Telegram: @K_I_R07

Моя электронная почта: hanikaevaleksandr5@gmail.com

